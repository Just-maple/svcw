//+build !svcw

package svcw

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"

	"golang.org/x/tools/imports"
)

const (
	genHead = "//+build svcw\n// Code generated by SvcWrap. DO NOT EDIT.\n\n"
)

var (
	l       = log.New(os.Stdout, "[SVCW] ", 0)
	modPath = getGoModDir()
)

type (
	wrap struct {
		collects map[string]*dir
	}

	dir struct {
		pkg  string
		data []string
	}

	parseType func(p reflect.Type)(todo string)
)

func Gen(i interface{}, todo parseType, recursive bool) (err error) {
	typ := reflect.ValueOf(i)
	var w = new(wrap)
	err = w.gen(typ, todo, recursive)
	if err != nil {
		return
	}
	err = w.write()
	if err != nil {
		return
	}
	return
}

func (w *wrap) gen(typ reflect.Value, todo parseType, recursive bool) (err error) {
	for typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}
	fileDir := getImportPath(typ.Type().PkgPath())
	if !strings.Contains(fileDir, modPath) || strings.Contains(fileDir, "vendor") {
		return
	}

	var (
		data []string
		nf   = typ.NumField()
	)

	for i := 0; i < nf; i++ {
		var (
			fieldData []string
			itf       = typ.Field(i)
		)
		if itf.Kind() != reflect.Interface || itf.IsNil() {
			continue
		}
		tf := itf.Elem()
		if tf.Kind() == reflect.Ptr {
			tf = tf.Elem()
		}
		if typ.Kind() != reflect.Struct || !typ.IsValid() {
			continue
		}
		tfp := tf.Type().PkgPath()
		tfDir := getImportPath(tfp)
		if recursive && strings.Contains(tfDir, modPath) && !strings.Contains(tfDir, "vendor") {
			err = w.gen(tf, todo, recursive)
			if err != nil {
				return
			}
		}

		var (
			nm    = itf.NumMethod()
			ft    = typ.Type().Field(i)
			fname = ft.Name
			wrap  = "_w_" + typ.Type().Name() + "_" + fname

			field = itf.Type().String()
		)

		if itf.Type().PkgPath() == typ.Type().PkgPath() {
			field = itf.Type().Name()
		}

		fieldData = append(fieldData, fmt.Sprintf("type %s struct{ %s }\n\n", wrap, field))
		fieldData = append(fieldData, fmt.Sprintf(`var _ = wrapflask.Register(%s{},new(%s))`, wrap, field))
		var funcs []string
		for j := 0; j < nm; j++ {
			var (
				c         []string
				paramCall []string
				o         []string
				ret       []string
				m         = itf.Type().Method(j).Name
				pre       = fmt.Sprintf("func(this %s)"+m, wrap)
				ft        = itf.Type().Method(j).Type
			)

			if ft.NumIn() == 0 || ft.In(0).String() != "context.Context" {
				continue
			}

			for ni := 0; ni < ft.NumIn(); ni++ {
				paramCall = append(paramCall, "p"+strconv.Itoa(ni))
				c = append(c, fmt.Sprintf("p%d %s", ni, ft.In(ni).String()))
			}
			for ni := 0; ni < ft.NumOut(); ni++ {
				ret = append(ret, "r"+strconv.Itoa(ni))
				o = append(o, fmt.Sprintf("r%d %s", ni, ft.Out(ni).String()))
			}
			re := strings.Join(ret, ",")
			if len(ret) > 0 {
				re += " ="
			}
			f := pre + fmt.Sprintf("(%s)(%s){\n%s\n%s\n}\n",
				strings.Join(c, ","),
				strings.Join(o, ","),
				todo(ft),
				fmt.Sprintf("%s this.%s.%s(%s)\nreturn", re, typ.Type().Field(i).Type.Name(), m, strings.Join(paramCall, ",")),
			)
			funcs = append(funcs, f)
		}
		if len(funcs) == 0 {
			continue
		}
		data = append(data, fieldData...)
		data = append(data, funcs...)
	}
	tmpStr := strings.TrimSpace(strings.Join(data, "\n"))
	if len(tmpStr) == 0 {
		return
	}
	d, ok := w.collects[fileDir]
	if !ok {
		d = new(dir)
		d.pkg = strings.Split(typ.Type().String(), ".")[0]
		if w.collects == nil {
			w.collects = map[string]*dir{}
		}
		w.collects[fileDir] = d
	}
	for _, d := range d.data {
		if d == tmpStr {
			break
		}
	}
	d.data = append(d.data, tmpStr)
	return
}

func (w *wrap) write() (err error) {
	for dir, w := range w.collects {
		bf := bytes.NewBufferString(genHead + `package ` + w.pkg + "\n" + strings.Join(w.data, "\n\n"))
		b, err := imports.Process("", bf.Bytes(), nil)
		if err != nil {
			return err
		}
		fname := filepath.Join(dir, "zitf.go")
		l.Printf("Gen:%v", fname)
		err = ioutil.WriteFile(fname, b, 0664)
	}
	return
}
